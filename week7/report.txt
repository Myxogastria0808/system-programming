---

学籍番号: 202310330
名前: 長田 悠生
課題番号： 7
練習問題番号：704
題名： ネットワーク・プログラミング／サーバ側(1)

[環境]
OSの環境等は以下の通りである。

OS: NixOS 25.05 (Warbler) x86_64
gcc version: 14.2.1 20250322

以下のflake.nixの環境で課題に取り組んだ。
今回は、telnetを利用するために、`inetutils`を
flake.nixに追加している。

```nix
{
  description = "clang flake sample";
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs =
    inputs:
    inputs.flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = inputs.nixpkgs.legacyPackages.${system};
      in
      {
        devShells.default = pkgs.mkShell {
          packages = with pkgs; [
            gcc
            gnumake
            inetutils
          ];
        };
      }
    );
}
```

[練習問題704 概要]
コマンドラインからファイル名を受け取り、
画面に対して HTTPの応答を返すプログラムを作成した。

[練習問題704 実行結果]

練習問題に掲載されているサンプルファイルをそのまま利用して、
以下のように作成したプログラムを実行した。
期待した通りの結果が得られた。

```sh
$ gcc main.c
$ ./a.out < good-request.txt
requestline is [GET /index.html HTTP/1.0]
Ignored: Host: azalea16:1231
Ignored: User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:127.0) Gecko/20100101 Firefox/127.0
Ignored: Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Ignored: Accept-Language: ja,en-US;q=0.7,en;q=0.3
Ignored: Accept-Encoding: gzip, deflate
Ignored: Connection: keep-alive
Ignored: Upgrade-Insecure-Requests: 1
Ignored: Priority: u=1
filename is [/index.html].

$ ./a.out < http-bad-request-1.txt
Expected 3 parts, got 2.
Bad request.

$ ./a.out < http-bad-request-2.txt
Expected 3 parts, got 4.
Bad request.

$ ./a.out < http-bad-request-3.txt
Expected 'GET', got 'GETa'.
Bad request.

```

[練習問題704 考察]
それぞれのバリデーションのエラーが
適切に処理されていることが出力結果から確認することができる。
freeに該当する関数を利用しているため、プログラムが異常な状態で終了することはない。

[練習問題704 プログラム]

- int http_receive_request(FILE *in, char *filename, size_t size)

http-request-analyze.c の http_receive_request関数を改造している。

1.の要件は以下が該当する

[要件]
requestline に「<」や「..」が含まれていたら、エラー。

```c
// 1. if the requestline contains '<' or '..', it's dangerous
if (strchr(requestline, '<') || strstr(requestline, "..")) {
    fprintf(stderr, "Dangerous request line found.\n");
    return (0);
}
```

2. の要件は以下が該当する

[要件]
requestline を string_split() 等で、
空白「 ''」を区切り文字として分割する。
string_split() は、内部で malloc() を呼んでメモリを確保している。

```c
// 2. split the requestline
int count;
char **vec;
chomp(requestline); /* remove \r\n */
if (string_split(requestline, ' ', &count, &vec) < 0) {
    perror("string_split-malloc");
    exit(1);
}
```

3. の要件は以下が該当する

[要件]
要素数が 3 でなければエラー。

```c
// 3. if the count is not 3, it's a bad request
if (count != 3) {
    fprintf(stderr, "Expected 3 parts, got %d.\n", count);
    free_string_vector(count, vec);
    return (0);
}
```

4. の要件は以下が該当する

[要件]
最初の要素が "GET" でなければエラー。

```c
// 4. if the first part is not "GET", it's a bad request
if (strcmp(vec[0], "GET") != 0) {
    fprintf(stderr, "Expected 'GET', got '%s'.\n", vec[0]);
    free_string_vector(count, vec);
    return (0);
}
```

5. の要件は以下が該当する

[要件]
最後の要素が "HTTP/1.0" か "HTTP/1.1" でなければエラー。

```c
// 5. if the last part is not "HTTP/1.0" or "HTTP/1.1", it's a bad request
if (strcmp(vec[2], "HTTP/1.0") != 0 && strcmp(vec[2], "HTTP/1.1") != 0) {
    fprintf(stderr, "Expected 'HTTP/1.0' or 'HTTP/1.1', got '%s'.\n",
            vec[2]);
    // free
    free_string_vector(count, vec);
    return (0);
}
```

6. の要件は以下が該当する

[要件]
2つ目の要素を filename にコピーする。

```c
// 6. copy the second part to filename
snprintf(filename, size, "%s", vec[1]);
```

7. の要件は以下が該当する

[要件]
string_split()を使っていた時には、
free_string_vector() を呼び、メモリを解放する。

```c
// 7. free
free_string_vector(count, vec);
```

8. の要件は以下が該当する

[要件]
return 1 で、成功したことを返す。

```c
// 8. return 1 to indicate success
return (1);
```

```c
int http_receive_request(FILE *in, char *filename, size_t size) {
    char requestline[BUFFERSIZE];
    char rheader[BUFFERSIZE];

    snprintf(filename, size, "NOFILENAME");
    if (fgets(requestline, BUFFERSIZE, in) <= 0) {
        printf("No request line.\n");
        return (0);
    }

    // validation of requestline
    // 1. if the requestline contains '<' or '..', it's dangerous
    if (strchr(requestline, '<') || strstr(requestline, "..")) {
        fprintf(stderr, "Dangerous request line found.\n");
        return (0);
    }
    // 2. split the requestline
    int count;
    char **vec;
    chomp(requestline); /* remove \r\n */
    if (string_split(requestline, ' ', &count, &vec) < 0) {
        perror("string_split-malloc");
        exit(1);
    }
    // 3. if the count is not 3, it's a bad request
    if (count != 3) {
        fprintf(stderr, "Expected 3 parts, got %d.\n", count);
        free_string_vector(count, vec);
        return (0);
    }
    // 4. if the first part is not "GET", it's a bad request
    if (strcmp(vec[0], "GET") != 0) {
        fprintf(stderr, "Expected 'GET', got '%s'.\n", vec[0]);
        free_string_vector(count, vec);
        return (0);
    }
    // 5. if the last part is not "HTTP/1.0" or "HTTP/1.1", it's a bad request
    if (strcmp(vec[2], "HTTP/1.0") != 0 && strcmp(vec[2], "HTTP/1.1") != 0) {
        fprintf(stderr, "Expected 'HTTP/1.0' or 'HTTP/1.1', got '%s'.\n",
                vec[2]);
        // free
        free_string_vector(count, vec);
        return (0);
    }

    printf("requestline is [%s]\n", requestline);
    while (fgets(rheader, BUFFERSIZE, in)) {
        chomp(rheader); /* remove \r\n */
        if (strcmp(rheader, "") == 0) break;
        printf("Ignored: %s\n", rheader);
    }
    if (strchr(requestline, '<') || strstr(requestline, "..")) {
        printf("Dangerous request line found.\n");
        return (0);
    }
    // 6. copy the second part to filename
    snprintf(filename, size, "%s", vec[1]);
    // 7. free
    free_string_vector(count, vec);
    // 8. return 1 to indicate success
    return (1);
}
```

- main.c

以下がプログラムの全体である。
http=request-analyze.cを改造している。

```c
#include <stdio.h>  /* fprintf() */
#include <stdlib.h> /* exit() */
#include <string.h> /* strcmp() */

extern int http_receive_request(FILE *in, char *filename, size_t size);
extern char *chomp(char *str);
extern int string_split(char *str, char del, int *countp, char ***vecp);
extern void free_string_vector(int qc, char **vec);
extern int countchr(char *s, char c);

#define BUFFERSIZE 1024

int main(int argc, char *argv[]) {
    char filename[BUFFERSIZE];
    int res;

    if (argc != 1) {
        fprintf(stderr, "Usage: %s < request-filename\n", argv[0]);
        exit(1);
    }
    res = http_receive_request(stdin, filename, BUFFERSIZE);
    if (res)
        printf("filename is [%s].\n", filename);
    else
        printf("Bad request.\n");
}

int http_receive_request(FILE *in, char *filename, size_t size) {
    char requestline[BUFFERSIZE];
    char rheader[BUFFERSIZE];

    snprintf(filename, size, "NOFILENAME");
    if (fgets(requestline, BUFFERSIZE, in) <= 0) {
        printf("No request line.\n");
        return (0);
    }

    // validation of requestline
    // 1. if the requestline contains '<' or '..', it's dangerous
    if (strchr(requestline, '<') || strstr(requestline, "..")) {
        fprintf(stderr, "Dangerous request line found.\n");
        return (0);
    }
    // 2. split the requestline
    int count;
    char **vec;
    chomp(requestline); /* remove \r\n */
    if (string_split(requestline, ' ', &count, &vec) < 0) {
        perror("string_split-malloc");
        exit(1);
    }
    // 3. if the count is not 3, it's a bad request
    if (count != 3) {
        fprintf(stderr, "Expected 3 parts, got %d.\n", count);
        free_string_vector(count, vec);
        return (0);
    }
    // 4. if the first part is not "GET", it's a bad request
    if (strcmp(vec[0], "GET") != 0) {
        fprintf(stderr, "Expected 'GET', got '%s'.\n", vec[0]);
        free_string_vector(count, vec);
        return (0);
    }
    // 5. if the last part is not "HTTP/1.0" or "HTTP/1.1", it's a bad request
    if (strcmp(vec[2], "HTTP/1.0") != 0 && strcmp(vec[2], "HTTP/1.1") != 0) {
        fprintf(stderr, "Expected 'HTTP/1.0' or 'HTTP/1.1', got '%s'.\n",
                vec[2]);
        // free
        free_string_vector(count, vec);
        return (0);
    }

    printf("requestline is [%s]\n", requestline);
    while (fgets(rheader, BUFFERSIZE, in)) {
        chomp(rheader); /* remove \r\n */
        if (strcmp(rheader, "") == 0) break;
        printf("Ignored: %s\n", rheader);
    }
    if (strchr(requestline, '<') || strstr(requestline, "..")) {
        printf("Dangerous request line found.\n");
        return (0);
    }
    // 6. copy the second part to filename
    snprintf(filename, size, "%s", vec[1]);
    // 7. free
    free_string_vector(count, vec);
    // 8. return 1 to indicate success
    return (1);
}

char *chomp(char *str) {
    int len;

    len = strlen(str);
    if (len >= 2 && str[len - 2] == '\r' && str[len - 1] == '\n') {
        str[len - 2] = str[len - 1] = 0;
    } else if (len >= 1 && (str[len - 1] == '\r' || str[len - 1] == '\n')) {
        str[len - 1] = 0;
    }
    return (str);
}

int string_split(char *str, char del, int *countp, char ***vecp) {
    char **vec;
    int count_max, i, len;
    char *s, *p;

    if (str == 0) return (-1);
    count_max = countchr(str, del) + 1;
    vec = malloc(sizeof(char *) * (count_max + 1));
    if (vec == 0) return (-1);

    for (i = 0; i < count_max; i++) {
        while (*str == del) str++;
        if (*str == 0) break;
        for (p = str; *p != del && *p != 0; p++) continue;
        /* *p == del || *p=='\0' */
        len = p - str;
        s = malloc(len + 1);
        if (s == 0) {
            int j;
            for (j = 0; j < i; j++) {
                free(vec[j]);
                vec[j] = 0;
            }
            free(vec);
            return (-1);
        }
        memcpy(s, str, len);
        s[len] = 0;
        vec[i] = s;
        str = p;
    }
    vec[i] = 0;
    *countp = i;
    *vecp = vec;
    return (i);
}

void free_string_vector(int qc, char **vec) {
    int i;
    for (i = 0; i < qc; i++) {
        if (vec[i] == NULL) break;
        free(vec[i]);
    }
    free(vec);
}

int countchr(char *s, char c) {
    int count;
    for (count = 0; *s; s++)
        if (*s == c) count++;
    return (count);
}

```

---
