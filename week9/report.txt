---

学籍番号: 202310330
名前: 長田 悠生
課題番号: 9
練習問題番号: 911
題名: Web CGI プログラミング(1)

[環境]
OSの環境等は以下の通りである。

OS: NixOS 25.05 (Warbler) x86_64
gcc version: 14.3.0

以下のflake.nixの環境で課題に取り組んだ。

```nix
{
  description = "clang flake sample";
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs =
    inputs:
    inputs.flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = inputs.nixpkgs.legacyPackages.${system};
      in
      {
        devShells.default = pkgs.mkShell {
          packages = with pkgs; [
            gcc
            gnumake
          ];
        };
      }
    );
}
```

[練習問題911 概要]
CGIを想定したカウンターの実装を行う。
`op`と`val`の2つのパラメータを受け取り、
`op`が`inc`の場合はカウンターを1増加させ、
`set`の場合は`val`の値をカウンターに設定する。

[練習問題911 実行結果]
環境変数に正常な値を設定した場合は、
期待通りのカウンターの値が出力されることがわかる。
環境変数に不正な値を設定した場合は、
期待したエラーが出力されていることがわかる。

```sh
$ gcc main.c
$ export REQUEST_METHOD=GET
$ export QUERY_STRING='op=set&val=0'
$ ./a.out
Content-Type: text/html                                                                                                                                                                       <HTML><HEAD></HEAD><BODY><PRE>
0
</PRE></BODY></HTML>

$ export QUERY_STRING='op=inc'
$ ./a.out                                                                                                                                                                     <HTML><HEAD></HEAD><BODY><PRE>
Content-Type: text/html

<HTML><HEAD></HEAD><BODY><PRE>
1
</PRE></BODY></HTML>

$ ./a.out
Content-Type: text/html

<HTML><HEAD></HEAD><BODY><PRE>
2
</PRE></BODY></HTML>

$ export QUERY_STRING='op=none'
$ ./a.out
Content-Type: text/html

<HTML><HEAD></HEAD><BODY><PRE>
Error: Unknown operation 'none'.
Valid operations are 'inc' and 'set'.

$ export QUERY_STRING='op=set'
$ ./a.out
Content-Type: text/html

<HTML><HEAD></HEAD><BODY><PRE>
Error: 'set' operation requires a value.

$ export QUERY_STRING='op=set&val='
$ ./a.out
Content-Type: text/html

<HTML><HEAD></HEAD><BODY><PRE>
Error: 'set' operation requires a value.

$ export QUERY_STRING='op=set&val=abc'
$ ./a.out
Content-Type: text/html

<HTML><HEAD></HEAD><BODY><PRE>
Error: Invalid value 'abc' for 'set' operation.

$ export QUERY_STRING='op=set&val=100xxx'
$ ./a.out
Content-Type: text/html

<HTML><HEAD></HEAD><BODY><PRE>
100
</PRE></BODY></HTML>

```

[練習問題911 考察]
この課題では、CGIを想定したカウンターの実装を行った。
`op`と`val`の2つのパラメータを受け取り、
`op`が`inc`の場合はカウンターを1増加させ、
`set`の場合は`val`の値をカウンターに設定する。
`op`が不正な値の場合はエラーを出力する。
`op`に`set`が設定されている場合は、
`val`が空でないことを確認し、空の場合はエラーを出力する。
`val`が不正な値の場合は、エラーを出力する。
これらの動作が正常に行えていることを出力結果より確認した。

[練習問題911 プログラム]
基本的には、`cgi-opval.c`の一部を改変している。
主要な変更点は以下の通りである。

- `void counter_save(int counter)` と`int counter_load(void)`

これらの関数は、`file-counter.c`にあった関数を流用している。

```c
#define DATA_FILENAME "file-counter-value.data"

void counter_save(int counter) {
    FILE *f;
    f = fopen(DATA_FILENAME, "w");
    if (f == NULL) {
        perror(DATA_FILENAME);
        exit(2);
    }
    if (fwrite(&counter, sizeof(counter), 1, f) != 1) {
        perror("fwrite");
        fclose(f);
        exit(2);
    }
    fclose(f);
}

int counter_load() {
    FILE *f;
    int counter;
    f = fopen(DATA_FILENAME, "r");
    if (f == NULL) {
        return 0;
    }
    if (fread(&counter, sizeof(counter), 1, f) != 1) {
        perror("fread");
        fclose(f);
        exit(2);
    }
    fclose(f);
    return counter;
}
```

- 自作関数

`void counter(char *op, char *val)`という関数を自作している。
この関数は、`op`の値に応じて、カウンターを増加させたり、設定したりする。
`op`が`inc`の場合はカウンターを1増加させ、
`set`の場合は`val`の値をカウンターに設定する。
`op`が不正な値の場合はエラーを出力する。
また、`op`に`set`が設定されている場合は、
`val`が空でないことを確認し、空の場合はエラーを出力する。
`val`が不正な値の場合は、エラーを出力する。

```c
void counter(char *op, char *val) {
    int counter = 0;
    char *endp;

    if (strcmp(op, "inc") == 0) {
        // op="inc"
        counter = counter_load();
        counter++;
        counter_save(counter);
        printf("%d\n", counter);
    } else if (strcmp(op, "set") == 0) {
        // op="set"
        if (val == NULL || strlen(val) == 0) {
            // empty val error
            fprintf(stderr, "Error: 'set' operation requires a value.\n");
            exit(EXIT_FAILURE);
        } else {
            counter = strtol(val, &endp, 10);
            if (val == endp) {
                // invalid number error
                fprintf(stderr,
                        "Error: Invalid value '%s' for 'set' operation.\n",
                        val);
                exit(EXIT_FAILURE);
            }
            counter_save(counter);
            printf("%d\n", counter);
        }
    } else {
        // unknown op
        fprintf(stderr, "Error: Unknown operation '%s'.\n", op);
        fprintf(stderr, "Valid operations are 'inc' and 'set'.\n");
        exit(EXIT_FAILURE);
    }
}
```

- main.c

以下がmain.cの全体のコードである。

上記の変更以外にも、いくつかのささいな変更をしているが、
あまり本質とは関係ないので、説明を省略する。

```c
#include <ctype.h>  /* isdigit() */
#include <stdio.h>  /* printf(), stderr, fopen(), fread(), frwite(), fclose() */
#include <stdlib.h> /* getenv(), malloc(), exit(), strtol() */
#include <string.h> /* strlen(), strcmp() */
#include <sys/types.h> /* read() */
#include <sys/uio.h>   /* read() */
#include <unistd.h>    /* read() */

extern void print_header(void);
extern void print_content(void);
extern char *get_query_string();
extern char *read_query_string();
extern void safe_printenv(char *name);
extern void counter_save(int counter);     // import from file-counter.c
extern int counter_load(void);             // import from file-counter.c
extern void counter(char *op, char *val);  // my original function
extern void safe_print_string(char *str);
extern char *html_escape(char *str);
extern char *decode_url(char *str);
extern char *getparam(int qc, char *qv[], char *name);

extern int string_split(char *str, char del, int *countp, char ***vecp);
extern void free_string_vector(int qc, char **vec);
extern int countchr(char *s, char c);

/* main */
int main() {
    print_header();
    print_content();
}

/* show header */
void print_header() {
    printf("Content-Type: text/html\n");
    printf("\n");
}

/* show body */
void print_content() {
    char *query_string;
    int qc;
    char **qv;
    char *op, *val;

    printf("<HTML><HEAD></HEAD><BODY><PRE>\n");
    /* get raw query string */
    query_string = get_query_string();
    if (query_string == NULL) {
        printf("No query string.\n");
    } else if (
        /* parse raw query string */
        string_split(query_string, '&', &qc, &qv) < 0) {
        printf("Error while parsing query string\n");
    } else {
        /* get op and val variables from query */
        op = getparam(qc, qv, "op");
        val = getparam(qc, qv, "val");

        /* count process */
        counter(op, val);

        /* free */
        free_string_vector(qc, qv);
    }

    printf("</PRE></BODY></HTML>\n");
    if (query_string) free(query_string);
}

/* get environment variables */
char *get_query_string() {
    char *request_method, *query_string;
    request_method = getenv("REQUEST_METHOD");
    if (request_method == 0)
        return (0);
    else if (strcmp(request_method, "GET") == 0) {
        /* GET method */
        query_string = getenv("QUERY_STRING");
        if (query_string == 0)
            return (0);
        else
            return (strdup(query_string));
    } else if (strcmp(request_method, "POST") == 0) {
        /* POST method */
        return (read_query_string());
    } else {
        /* unknown method */
        printf("Unknown method: ");
        safe_print_string(request_method);
        printf("\n");
        return (0);
    }
}

/* parse POST method variables */
char *read_query_string() {
    int clen;
    char *content_length;
    char *buf;

    content_length = getenv("CONTENT_LENGTH");
    if (content_length == 0) {
        return (0);
    } else {
        clen = strtol(content_length, 0, 10);
        buf = malloc(clen + 1);
        if (buf == 0) {
            printf("read_query_string(): no memory\n");
            exit(-1);
        }
        if (read(0, buf, clen) != clen) {
            printf("read error.\n");
            exit(-1);
        }
        buf[clen] = 0;
        return (buf);
    }
}

void safe_printenv(char *name) {
    char *val;

    printf("%s=", name);
    val = getenv(name);
    safe_print_string(val);
    printf("\n");
}

/* import from file-counter.c area -start- */
#define DATA_FILENAME "file-counter-value.data"

void counter_save(int counter) {
    FILE *f;
    f = fopen(DATA_FILENAME, "w");
    if (f == NULL) {
        perror(DATA_FILENAME);
        exit(2);
    }
    if (fwrite(&counter, sizeof(counter), 1, f) != 1) {
        perror("fwrite");
        fclose(f);
        exit(2);
    }
    fclose(f);
}

int counter_load() {
    FILE *f;
    int counter;
    f = fopen(DATA_FILENAME, "r");
    if (f == NULL) {
        return 0;
    }
    if (fread(&counter, sizeof(counter), 1, f) != 1) {
        perror("fread");
        fclose(f);
        exit(2);
    }
    fclose(f);
    return counter;
}
/* import from file-counter.c area -end- */

/* my original function -start- */
void counter(char *op, char *val) {
    int counter = 0;
    char *endp;

    if (strcmp(op, "inc") == 0) {
        // op="inc"
        counter = counter_load();
        counter++;
        counter_save(counter);
        printf("%d\n", counter);
    } else if (strcmp(op, "set") == 0) {
        // op="set"
        if (val == NULL || strlen(val) == 0) {
            // empty val error
            fprintf(stderr, "Error: 'set' operation requires a value.\n");
            exit(EXIT_FAILURE);
        } else {
            counter = strtol(val, &endp, 10);
            if (val == endp) {
                // invalid number error
                fprintf(stderr,
                        "Error: Invalid value '%s' for 'set' operation.\n",
                        val);
                exit(EXIT_FAILURE);
            }
            counter_save(counter);
            printf("%d\n", counter);
        }
    } else {
        // unknown op
        fprintf(stderr, "Error: Unknown operation '%s'.\n", op);
        fprintf(stderr, "Valid operations are 'inc' and 'set'.\n");
        exit(EXIT_FAILURE);
    }
}
/* my original function -end- */

void safe_print_string(char *str) {
    char *safe_str;

    if (str == 0) {
        printf("(null)");
        return;
    }
    safe_str = html_escape(str);
    if (safe_str == 0) {
        printf("(no memory)");
    } else {
        printf("%s", safe_str);
        free(safe_str);
    }
}

char *html_escape(char *str) {
    int len;
    char c, *tmp, *p, *res;

    len = strlen(str);
    tmp = malloc(len * 6 + 1);
    if (tmp == 0) return (0);
    p = tmp;
    while ((c = *str++)) {
        switch (c) {
            case '&':
                memcpy(p, "&amp;", 5);
                p += 5;
                break;
            case '<':
                memcpy(p, "&lt;", 4);
                p += 4;
                break;
            case '>':
                memcpy(p, "&gt;", 4);
                p += 4;
                break;
            case '"':
                memcpy(p, "&quot;", 6);
                p += 6;
                break;
            default:
                *p = c;
                p++;
                break;
        }
    }
    *p = 0;
    res = strdup(tmp);
    free(tmp);
    return (res);
}

char *decode_url(char *str) {
    int len;
    char c, *tmp, *p, *res;

    len = strlen(str);
    tmp = malloc(len + 1);
    if (tmp == 0) return (0);
    p = tmp;

    while (*str) {
        if (*str == '%' && isxdigit(*(str + 1)) && isxdigit(*(str + 2))) {
            char hexstr[3];
            hexstr[0] = *(str + 1);
            hexstr[1] = *(str + 2);
            hexstr[2] = 0;
            c = strtol(hexstr, 0, 16);
            *p++ = c;
            str += 3;
        } else if (*str == '+') {
            *p++ = ' ';
            str++;
        } else {
            *p++ = *str;
            str++;
        }
    }
    *p = 0;
    res = strdup(tmp);
    free(tmp);
    return (res);
}

/* get query parameter */
char *getparam(int qc, char *qv[], char *name) {
    int i;
    size_t len;

    len = strlen(name);
    for (i = 0; i < qc; i++) {
        if (strncmp(qv[i], name, len) == 0 && qv[i][len] == '=') {
            return (&qv[i][len + 1]);
        }
    }
    return (NULL);
}

/* split query string into vector */
int string_split(char *str, char del, int *countp, char ***vecp) {
    char **vec;
    int count_max, i, len;
    char *s, *p;

    if (str == 0) return (-1);
    count_max = countchr(str, del) + 1;
    vec = malloc(sizeof(char *) * (count_max + 1));
    if (vec == 0) return (-1);

    for (i = 0; i < count_max; i++) {
        while (*str == del) str++;
        if (*str == 0) break;
        for (p = str; *p != del && *p != 0; p++) continue;
        /* *p == del || *p=='\0' */
        len = p - str;
        s = malloc(len + 1);
        if (s == 0) {
            int j;
            for (j = 0; j < i; j++) {
                free(vec[j]);
                vec[j] = 0;
            }
            return (-1);
        }
        memcpy(s, str, len);
        s[len] = 0;
        vec[i] = s;
        str = p;
    }
    vec[i] = 0;
    *countp = i;
    *vecp = vec;
    return (i);
}

/* free string vector */
void free_string_vector(int qc, char **vec) {
    int i;
    for (i = 0; i < qc; i++) {
        if (vec[i] == NULL) break;
        free(vec[i]);
    }
    free(vec);
}

int countchr(char *s, char c) {
    int count;
    for (count = 0; *s; s++)
        if (*s == c) count++;
    return (count);
}

```

---
