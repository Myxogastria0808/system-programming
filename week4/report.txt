---

学籍番号: 202310330
名前: 長田 悠生
課題番号：4
練習問題番号：404, 405
題名：プロセス制御

[環境]

OSの環境等は以下の通りである。

OS: NixOS 25.05 (Warbler) x86_64
gcc version: 14.2.1 20250322

以下のflake.nixの環境で課題に取り組んだ。

```nix
{
  description = "clang flake sample";
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs =
    inputs:
    inputs.flake-utils.lib.eachDefaultSystem (
      system:
      let
        pkgs = inputs.nixpkgs.legacyPackages.${system};
      in
      {
        devShells.default = pkgs.mkShell {
          packages = with pkgs; [
            gcc
            gnumake
          ];
        };
      }
    );
}
```

[練習問題404 概要]
systemというライブラリ関数を自作する。

[練習問題404 実行結果]
パイプやリダイレクションを含むコマンドが正常に実行できていることが
出力結果から確認できる。

```sh
$ gcc main.c
$ ./a.out
Executing command: echo Hello, World!
Hello, World!
Executing command2: echo Hello, World! > output.txt | sed -e "s/World/Universe/g" output.txt
Hello, Universe!
Executing command3: cat output.txt
Hello, World!
```

[練習問題404 考察]
manコマンドで確認した際に、system関数の内部で`execl("/bin/sh", "sh", "-c", command, NULL)`
が呼ばれていることがわかったので、execlを使ってコマンドを実行するようにした。
実際に実行してみると、パイプやリダイレクションを含むコマンドも正常に実行できていることが確認できた。

[練習問題404 プログラム]

- mysystem関数
system関数と同様、`execl("/bin/sh", "sh", "-c", command, NULL)`
を内部で呼び出すように実装した。
execlは、forkした子プロセス内で実行するようにしている。

```c
int mysystem_child(const char *command) {
    return execl("/bin/sh", "sh", "-c", command, NULL);
}

int mysystem(const char *command) {
    // NULL check
    if (command == NULL) {
        return EXIT_FAILURE;
    }

    int child, status;

    // create a child process
    if ((child = fork()) < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (child == 0) {
        // run the command using execl
        return mysystem_child(command);
    } else {
        // wait for the child process to finish
        if (wait(&status) < 0) {
            perror("wait");
            exit(EXIT_FAILURE);
        }
    }

    return EXIT_SUCCESS;
}
```

- main.c
mysystem関数を使って、いくつかのコマンドを実行するプログラムを作成した。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

// parent process
//  ↓
// fork -------------→|
//  ↓                 ↓
// wait              execl
//  |                 |
// wait for child     |
// process complete   |
//   |                ↓
//   |               exit
//   ↓                ↓
// restart execute ←---
//   ↓

int mysystem_child(const char *command) {
    return execl("/bin/sh", "sh", "-c", command, NULL);
}

int mysystem(const char *command) {
    // NULL check
    if (command == NULL) {
        return EXIT_FAILURE;
    }

    int child, status;

    // create a child process
    if ((child = fork()) < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (child == 0) {
        // run the command using execl
        return mysystem_child(command);
    } else {
        // wait for the child process to finish
        if (wait(&status) < 0) {
            perror("wait");
            exit(EXIT_FAILURE);
        }
    }

    return EXIT_SUCCESS;
}

int main() {
    int status;

    const char *command = "echo Hello, World!";
    const char *command2 =
        "echo Hello, World! > output.txt | sed -e \"s/World/Universe/g\" "
        "output.txt ";
    const char *command3 = "cat output.txt";

    // Call mysystem to execute some commands
    printf("Executing command: %s\n", command);
    status = mysystem(command);
    if (status < 0) {
        perror("mysystem");
        return EXIT_FAILURE;
    }

    printf("Executing command2: %s\n", command2);
    status = mysystem(command2);
    if (status < 0) {
        perror("mysystem");
        return EXIT_FAILURE;
    }

    printf("Executing command3: %s\n", command3);
    status = mysystem(command3);
    if (status < 0) {
        perror("mysystem");
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
```

[練習問題405 概要]


[練習問題405 実行結果]
`/etc/bashrc`に対して`wc`コマンドを実行し、
結果を`output.txt`にリダイレクションしている。
`output.txt`の内容を確認すると、
`wc /etc/bashrc`の出力と同じ内容になっていることがわかる。

```sh
$ gcc main.c
$ ./a.out /etc/bashrc output.txt
$ cat output.txt
  88  350 2631
$ wc /etc/bashrc
  88  350 2631 /etc/bashrc
```

[練習問題405 考察]
書き込むするファイルのファイルディスクリプタをstdinに、
書き込むファイルのファイルディスクリプタをstdoutにリダイレクションすることで、
`wc`コマンドを実行し、その結果を指定したファイルに書き込むことができた。
ファイルディスクリプタの変遷は、プログラム中のコメントアウトに記載している。

[練習問題405 プログラム]
ファイルディスクリプタを操作して、

0 ... stdin (still the terminal)
1 ... stdout (still the terminal)
2 ... stderr
N (e.g., 3) ... read_file_descriptor
N+1 (e.g., 4) ... write_file_descriptor

の状態から、以下のように変更している。

0 ... stdin (still the terminal)
1 ... stdout (still the terminal)
2 ... stderr
N (e.g., 3) ... read_file_descriptor
N+1 (e.g., 4) ... write_file_descriptor

この操作によって、正常に`wc`コマンドを実行し、
その結果を指定したファイルに書き込むことができる。

- main.c

```c
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// file descriptor 0 is stdin
// file descriptor 1 is stdout
// file descriptor 2 is stderr

// int dup(int oldfd);
// dup returns the lowest-numbered unused file descriptor,
// which refers to the same open file description as oldfd.

// int dup2(int oldfd, int newfd);
// dup2 duplicates oldfd to newfd, closing newfd first if necessary.

int main(int argc, char *argv[]) {
    int read_file_descriptor, write_file_descriptor;

    if (argc != 3) {
        fprintf(stderr, "Usage: %s file_name\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // open argv[1] file and get the file descriptor
    read_file_descriptor = open(argv[1], O_RDONLY);
    if (read_file_descriptor < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // open argv[2] file and get the file descriptor
    write_file_descriptor = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (write_file_descriptor < 0) {
        perror("open");
        close(read_file_descriptor);
        exit(EXIT_FAILURE);
    }

    // At this point, the file descriptors are likely:
    // 0 ... stdin (still the terminal)
    // 1 ... stdout (still the terminal)
    // 2 ... stderr
    // N (e.g., 3) ... read_file_descriptor
    // N+1 (e.g., 4) ... write_file_descriptor

    // switch stdin to read_file_descriptor
    if (dup2(read_file_descriptor, 0) < 0) {
        perror("dup2");
        close(read_file_descriptor);
        close(write_file_descriptor);
        exit(EXIT_FAILURE);
    }
    // close read_file_descriptor descriptor
    close(read_file_descriptor);

    // switch stdout to write_file_descriptor
    if (dup2(write_file_descriptor, 1) < 0) {
        perror("dup2");
        close(write_file_descriptor);
        exit(EXIT_FAILURE);
    }
    // close write_file_descriptor descriptor
    close(write_file_descriptor);

    // After dup2:
    // 0 ... stdin (now refers to the input file)
    // 1 ... stdout (now refers to the output file)
    // 2 ... stderr (unchanged)

    // execute the wc command
    // input ... stdin (read_file_descriptor)
    // output ... stdout (write_file_descriptor)
    execlp("wc", "wc", NULL);

    return EXIT_FAILURE;
}
```

---
